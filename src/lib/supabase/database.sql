-- Supabase Database Schema for Waffle Payments
-- Run this in your Supabase SQL Editor

-- Drop user_profiles view if it exists (we'll use subscribers instead)
DROP VIEW IF EXISTS public.user_profiles CASCADE;

-- Add wallet support to subscribers table
ALTER TABLE public.subscribers ADD COLUMN IF NOT EXISTS wallet_address TEXT UNIQUE;
ALTER TABLE public.subscribers ADD COLUMN IF NOT EXISTS auth_type TEXT DEFAULT 'email' CHECK (auth_type IN ('email', 'wallet'));

-- Create index for wallet address lookups
CREATE INDEX IF NOT EXISTS idx_subscribers_wallet_address ON public.subscribers(wallet_address);
CREATE INDEX IF NOT EXISTS idx_subscribers_auth_type ON public.subscribers(auth_type);

-- The subscribers table should already exist
-- If not, create it with this structure:
/*
CREATE TABLE IF NOT EXISTS public.subscribers (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
    email TEXT,
    full_name TEXT,
    name TEXT,
    avatar_url TEXT,
    wallet_address TEXT UNIQUE,
    auth_type TEXT DEFAULT 'email' CHECK (auth_type IN ('email', 'wallet')),
    credits INTEGER DEFAULT 0,
    subscription_tier TEXT,
    status TEXT DEFAULT 'active',
    is_admin BOOLEAN DEFAULT false,
    is_super_admin BOOLEAN DEFAULT false,
    is_email_verified BOOLEAN DEFAULT false,
    last_login TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
*/

-- Create credit_transactions table
CREATE TABLE IF NOT EXISTS public.credit_transactions (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    credits INTEGER NOT NULL,
    transaction_type TEXT NOT NULL CHECK (transaction_type IN ('purchase', 'usage', 'refund')),
    payment_method TEXT,
    amount_usd DECIMAL(10,2),
    transaction_hash TEXT,
    package_info JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create user_credits table (if you want to keep it separate from subscribers)
CREATE TABLE IF NOT EXISTS public.user_credits (
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
    balance INTEGER DEFAULT 0,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable Row Level Security
ALTER TABLE public.subscribers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.credit_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_credits ENABLE ROW LEVEL SECURITY;

-- RLS Policies for subscribers
CREATE POLICY "Users can view own profile" ON public.subscribers
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can update own profile" ON public.subscribers
    FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own profile" ON public.subscribers
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- RLS Policies for credit_transactions
CREATE POLICY "Users can view own transactions" ON public.credit_transactions
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Service role can manage transactions" ON public.credit_transactions
    FOR ALL USING (true);

-- RLS Policies for user_credits (if keeping this table)
CREATE POLICY "Users can view own credits" ON public.user_credits
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Service role can manage credits" ON public.user_credits
    FOR ALL USING (true);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_subscribers_user_id ON public.subscribers(user_id);
CREATE INDEX IF NOT EXISTS idx_subscribers_email ON public.subscribers(email);
CREATE INDEX IF NOT EXISTS idx_credit_transactions_user_created ON public.credit_transactions(user_id, created_at DESC);

-- Create function to update subscriber credits automatically
CREATE OR REPLACE FUNCTION update_subscriber_credits()
RETURNS TRIGGER AS $$
BEGIN
    -- Update credits in subscribers table
    UPDATE public.subscribers 
    SET credits = COALESCE(credits, 0) + NEW.credits,
        updated_at = NOW()
    WHERE user_id = NEW.user_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to automatically update subscriber credits on purchase
DROP TRIGGER IF EXISTS trigger_update_subscriber_credits ON public.credit_transactions;
CREATE TRIGGER trigger_update_subscriber_credits
    AFTER INSERT ON public.credit_transactions
    FOR EACH ROW
    WHEN (NEW.transaction_type = 'purchase')
    EXECUTE FUNCTION update_subscriber_credits();

-- =============================================
-- AUTO-CREATE SUBSCRIBERS FOR NEW USERS
-- =============================================

-- Function to automatically create a subscriber when a new user is created
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
    -- Insert new subscriber record
    INSERT INTO public.subscribers (
        user_id,
        email,
        full_name,
        auth_type,
        credits,
        status,
        created_at,
        updated_at
    ) VALUES (
        NEW.id,
        NEW.email,
        COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'name'),
        CASE 
            WHEN NEW.raw_user_meta_data->>'wallet_address' IS NOT NULL THEN 'wallet'
            ELSE 'email'
        END,
        100, -- Give new users 100 credits to start
        'active',
        NOW(),
        NOW()
    );
    
    -- If this is a wallet user, also set the wallet address
    IF NEW.raw_user_meta_data->>'wallet_address' IS NOT NULL THEN
        UPDATE public.subscribers 
        SET wallet_address = NEW.raw_user_meta_data->>'wallet_address'
        WHERE user_id = NEW.id;
    END IF;
    
    RETURN NEW;
END;
$$;

-- Create trigger to automatically create subscriber when new user signs up
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_user();

-- Grant necessary permissions to supabase_auth_admin
GRANT EXECUTE ON FUNCTION public.handle_new_user() TO supabase_auth_admin;
GRANT INSERT ON TABLE public.subscribers TO supabase_auth_admin;
GRANT UPDATE ON TABLE public.subscribers TO supabase_auth_admin; 