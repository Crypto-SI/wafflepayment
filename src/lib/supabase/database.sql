-- Supabase Database Schema for Waffle Payments
-- Run this in your Supabase SQL Editor

-- Drop user_profiles view if it exists (we'll use subscribers instead)
DROP VIEW IF EXISTS public.user_profiles CASCADE;

-- The subscribers table should already exist
-- If not, create it with this structure:
/*
CREATE TABLE IF NOT EXISTS public.subscribers (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
    email TEXT,
    full_name TEXT,
    name TEXT,
    avatar_url TEXT,
    credits INTEGER DEFAULT 0,
    subscription_tier TEXT,
    status TEXT DEFAULT 'active',
    is_admin BOOLEAN DEFAULT false,
    is_super_admin BOOLEAN DEFAULT false,
    is_email_verified BOOLEAN DEFAULT false,
    last_login TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
*/

-- Create credit_transactions table
CREATE TABLE IF NOT EXISTS public.credit_transactions (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    credits INTEGER NOT NULL,
    transaction_type TEXT NOT NULL CHECK (transaction_type IN ('purchase', 'usage', 'refund')),
    payment_method TEXT,
    amount_usd DECIMAL(10,2),
    transaction_hash TEXT,
    package_info JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create user_credits table (if you want to keep it separate from subscribers)
CREATE TABLE IF NOT EXISTS public.user_credits (
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
    balance INTEGER DEFAULT 0,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable Row Level Security
ALTER TABLE public.subscribers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.credit_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_credits ENABLE ROW LEVEL SECURITY;

-- RLS Policies for subscribers
CREATE POLICY "Users can view own profile" ON public.subscribers
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can update own profile" ON public.subscribers
    FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own profile" ON public.subscribers
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- RLS Policies for credit_transactions
CREATE POLICY "Users can view own transactions" ON public.credit_transactions
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Service role can manage transactions" ON public.credit_transactions
    FOR ALL USING (true);

-- RLS Policies for user_credits (if keeping this table)
CREATE POLICY "Users can view own credits" ON public.user_credits
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Service role can manage credits" ON public.user_credits
    FOR ALL USING (true);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_subscribers_user_id ON public.subscribers(user_id);
CREATE INDEX IF NOT EXISTS idx_subscribers_email ON public.subscribers(email);
CREATE INDEX IF NOT EXISTS idx_credit_transactions_user_created ON public.credit_transactions(user_id, created_at DESC);

-- Create function to update subscriber credits automatically
CREATE OR REPLACE FUNCTION update_subscriber_credits()
RETURNS TRIGGER AS $$
BEGIN
    -- Update credits in subscribers table
    UPDATE public.subscribers 
    SET credits = COALESCE(credits, 0) + NEW.credits,
        updated_at = NOW()
    WHERE user_id = NEW.user_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to automatically update subscriber credits on purchase
DROP TRIGGER IF EXISTS trigger_update_subscriber_credits ON public.credit_transactions;
CREATE TRIGGER trigger_update_subscriber_credits
    AFTER INSERT ON public.credit_transactions
    FOR EACH ROW
    WHEN (NEW.transaction_type = 'purchase')
    EXECUTE FUNCTION update_subscriber_credits(); 